package com.livefront.sealedenum.compilation.traversal

import com.livefront.sealedenum.EnumForSealedEnumProvider
import com.livefront.sealedenum.SealedEnum
import com.livefront.sealedenum.SealedEnumWithEnumProvider
import kotlin.Int
import kotlin.LazyThreadSafetyMode
import kotlin.String
import kotlin.collections.List
import kotlin.reflect.KClass

/**
 * An isomorphic enum for the sealed class [Tree]
 */
public enum class TreeLevelOrderEnum() {
    Tree_A,
    Tree_K,
    Tree_T,
    Tree_L_S,
    Tree_B_C_D,
    Tree_B_C_E,
    Tree_B_C_J,
    Tree_L_M_N,
    Tree_L_M_O,
    Tree_L_P_Q,
    Tree_L_P_R,
    Tree_B_C_F_G,
    Tree_B_C_F_H,
    Tree_B_C_F_I,
}

/**
 * The isomorphic [TreeLevelOrderEnum] for [this].
 */
public val Tree.levelOrderEnum: TreeLevelOrderEnum
    get() = TreeLevelOrderSealedEnum.sealedObjectToEnum(this)

/**
 * The isomorphic [Tree] for [this].
 */
public val TreeLevelOrderEnum.sealedObject: Tree
    get() = TreeLevelOrderSealedEnum.enumToSealedObject(this)

/**
 * An implementation of [SealedEnum] for the sealed class [Tree]
 */
public object TreeLevelOrderSealedEnum : SealedEnum<Tree>,
        SealedEnumWithEnumProvider<Tree, TreeLevelOrderEnum>,
        EnumForSealedEnumProvider<Tree, TreeLevelOrderEnum> {
    public override val values: List<Tree> by lazy(mode = LazyThreadSafetyMode.PUBLICATION) {
        listOf(
            Tree.A,
            Tree.K,
            Tree.T,
            Tree.L.S,
            Tree.B.C.D,
            Tree.B.C.E,
            Tree.B.C.J,
            Tree.L.M.N,
            Tree.L.M.O,
            Tree.L.P.Q,
            Tree.L.P.R,
            Tree.B.C.F.G,
            Tree.B.C.F.H,
            Tree.B.C.F.I
        )
    }


    public override val enumClass: KClass<TreeLevelOrderEnum>
        get() = TreeLevelOrderEnum::class

    public override fun ordinalOf(obj: Tree): Int = when (obj) {
        is Tree.A -> 0
        is Tree.K -> 1
        is Tree.T -> 2
        is Tree.L.S -> 3
        is Tree.B.C.D -> 4
        is Tree.B.C.E -> 5
        is Tree.B.C.J -> 6
        is Tree.L.M.N -> 7
        is Tree.L.M.O -> 8
        is Tree.L.P.Q -> 9
        is Tree.L.P.R -> 10
        is Tree.B.C.F.G -> 11
        is Tree.B.C.F.H -> 12
        is Tree.B.C.F.I -> 13
    }

    public override fun nameOf(obj: Tree): String = when (obj) {
        is Tree.A -> "Tree_A"
        is Tree.K -> "Tree_K"
        is Tree.T -> "Tree_T"
        is Tree.L.S -> "Tree_L_S"
        is Tree.B.C.D -> "Tree_B_C_D"
        is Tree.B.C.E -> "Tree_B_C_E"
        is Tree.B.C.J -> "Tree_B_C_J"
        is Tree.L.M.N -> "Tree_L_M_N"
        is Tree.L.M.O -> "Tree_L_M_O"
        is Tree.L.P.Q -> "Tree_L_P_Q"
        is Tree.L.P.R -> "Tree_L_P_R"
        is Tree.B.C.F.G -> "Tree_B_C_F_G"
        is Tree.B.C.F.H -> "Tree_B_C_F_H"
        is Tree.B.C.F.I -> "Tree_B_C_F_I"
    }

    public override fun valueOf(name: String): Tree = when (name) {
        "Tree_A" -> Tree.A
        "Tree_K" -> Tree.K
        "Tree_T" -> Tree.T
        "Tree_L_S" -> Tree.L.S
        "Tree_B_C_D" -> Tree.B.C.D
        "Tree_B_C_E" -> Tree.B.C.E
        "Tree_B_C_J" -> Tree.B.C.J
        "Tree_L_M_N" -> Tree.L.M.N
        "Tree_L_M_O" -> Tree.L.M.O
        "Tree_L_P_Q" -> Tree.L.P.Q
        "Tree_L_P_R" -> Tree.L.P.R
        "Tree_B_C_F_G" -> Tree.B.C.F.G
        "Tree_B_C_F_H" -> Tree.B.C.F.H
        "Tree_B_C_F_I" -> Tree.B.C.F.I
        else -> throw IllegalArgumentException("""No sealed enum constant $name""")
    }

    public override fun sealedObjectToEnum(obj: Tree): TreeLevelOrderEnum = when (obj) {
        is Tree.A -> TreeLevelOrderEnum.Tree_A
        is Tree.K -> TreeLevelOrderEnum.Tree_K
        is Tree.T -> TreeLevelOrderEnum.Tree_T
        is Tree.L.S -> TreeLevelOrderEnum.Tree_L_S
        is Tree.B.C.D -> TreeLevelOrderEnum.Tree_B_C_D
        is Tree.B.C.E -> TreeLevelOrderEnum.Tree_B_C_E
        is Tree.B.C.J -> TreeLevelOrderEnum.Tree_B_C_J
        is Tree.L.M.N -> TreeLevelOrderEnum.Tree_L_M_N
        is Tree.L.M.O -> TreeLevelOrderEnum.Tree_L_M_O
        is Tree.L.P.Q -> TreeLevelOrderEnum.Tree_L_P_Q
        is Tree.L.P.R -> TreeLevelOrderEnum.Tree_L_P_R
        is Tree.B.C.F.G -> TreeLevelOrderEnum.Tree_B_C_F_G
        is Tree.B.C.F.H -> TreeLevelOrderEnum.Tree_B_C_F_H
        is Tree.B.C.F.I -> TreeLevelOrderEnum.Tree_B_C_F_I
    }

    public override fun enumToSealedObject(`enum`: TreeLevelOrderEnum): Tree = when (enum) {
        TreeLevelOrderEnum.Tree_A -> Tree.A
        TreeLevelOrderEnum.Tree_K -> Tree.K
        TreeLevelOrderEnum.Tree_T -> Tree.T
        TreeLevelOrderEnum.Tree_L_S -> Tree.L.S
        TreeLevelOrderEnum.Tree_B_C_D -> Tree.B.C.D
        TreeLevelOrderEnum.Tree_B_C_E -> Tree.B.C.E
        TreeLevelOrderEnum.Tree_B_C_J -> Tree.B.C.J
        TreeLevelOrderEnum.Tree_L_M_N -> Tree.L.M.N
        TreeLevelOrderEnum.Tree_L_M_O -> Tree.L.M.O
        TreeLevelOrderEnum.Tree_L_P_Q -> Tree.L.P.Q
        TreeLevelOrderEnum.Tree_L_P_R -> Tree.L.P.R
        TreeLevelOrderEnum.Tree_B_C_F_G -> Tree.B.C.F.G
        TreeLevelOrderEnum.Tree_B_C_F_H -> Tree.B.C.F.H
        TreeLevelOrderEnum.Tree_B_C_F_I -> Tree.B.C.F.I
    }
}

/**
 * The index of [this] in the values list.
 */
public val Tree.levelOrderOrdinal: Int
    get() = TreeLevelOrderSealedEnum.ordinalOf(this)

/**
 * The name of [this] for use with valueOf.
 */
public val Tree.levelOrderName: String
    get() = TreeLevelOrderSealedEnum.nameOf(this)

/**
 * A list of all [Tree] objects.
 */
public val Tree.Companion.levelOrderValues: List<Tree>
    get() = TreeLevelOrderSealedEnum.values

/**
 * Returns an implementation of [SealedEnum] for the sealed class [Tree]
 */
public val Tree.Companion.levelOrderSealedEnum: TreeLevelOrderSealedEnum
    get() = TreeLevelOrderSealedEnum

/**
 * Returns the [Tree] object for the given [name].
 *
 * If the given name doesn't correspond to any [Tree], an [IllegalArgumentException] will be thrown.
 */
public fun Tree.Companion.levelOrderValueOf(name: String): Tree =
        TreeLevelOrderSealedEnum.valueOf(name)

/**
 * An isomorphic enum for the sealed class [Tree]
 */
public enum class TreePostOrderEnum() {
    Tree_B_C_F_G,
    Tree_B_C_F_H,
    Tree_B_C_F_I,
    Tree_B_C_D,
    Tree_B_C_E,
    Tree_B_C_J,
    Tree_L_M_N,
    Tree_L_M_O,
    Tree_L_P_Q,
    Tree_L_P_R,
    Tree_L_S,
    Tree_A,
    Tree_K,
    Tree_T,
}

/**
 * The isomorphic [TreePostOrderEnum] for [this].
 */
public val Tree.postOrderEnum: TreePostOrderEnum
    get() = TreePostOrderSealedEnum.sealedObjectToEnum(this)

/**
 * The isomorphic [Tree] for [this].
 */
public val TreePostOrderEnum.sealedObject: Tree
    get() = TreePostOrderSealedEnum.enumToSealedObject(this)

/**
 * An implementation of [SealedEnum] for the sealed class [Tree]
 */
public object TreePostOrderSealedEnum : SealedEnum<Tree>,
        SealedEnumWithEnumProvider<Tree, TreePostOrderEnum>,
        EnumForSealedEnumProvider<Tree, TreePostOrderEnum> {
    public override val values: List<Tree> by lazy(mode = LazyThreadSafetyMode.PUBLICATION) {
        listOf(
            Tree.B.C.F.G,
            Tree.B.C.F.H,
            Tree.B.C.F.I,
            Tree.B.C.D,
            Tree.B.C.E,
            Tree.B.C.J,
            Tree.L.M.N,
            Tree.L.M.O,
            Tree.L.P.Q,
            Tree.L.P.R,
            Tree.L.S,
            Tree.A,
            Tree.K,
            Tree.T
        )
    }


    public override val enumClass: KClass<TreePostOrderEnum>
        get() = TreePostOrderEnum::class

    public override fun ordinalOf(obj: Tree): Int = when (obj) {
        is Tree.B.C.F.G -> 0
        is Tree.B.C.F.H -> 1
        is Tree.B.C.F.I -> 2
        is Tree.B.C.D -> 3
        is Tree.B.C.E -> 4
        is Tree.B.C.J -> 5
        is Tree.L.M.N -> 6
        is Tree.L.M.O -> 7
        is Tree.L.P.Q -> 8
        is Tree.L.P.R -> 9
        is Tree.L.S -> 10
        is Tree.A -> 11
        is Tree.K -> 12
        is Tree.T -> 13
    }

    public override fun nameOf(obj: Tree): String = when (obj) {
        is Tree.B.C.F.G -> "Tree_B_C_F_G"
        is Tree.B.C.F.H -> "Tree_B_C_F_H"
        is Tree.B.C.F.I -> "Tree_B_C_F_I"
        is Tree.B.C.D -> "Tree_B_C_D"
        is Tree.B.C.E -> "Tree_B_C_E"
        is Tree.B.C.J -> "Tree_B_C_J"
        is Tree.L.M.N -> "Tree_L_M_N"
        is Tree.L.M.O -> "Tree_L_M_O"
        is Tree.L.P.Q -> "Tree_L_P_Q"
        is Tree.L.P.R -> "Tree_L_P_R"
        is Tree.L.S -> "Tree_L_S"
        is Tree.A -> "Tree_A"
        is Tree.K -> "Tree_K"
        is Tree.T -> "Tree_T"
    }

    public override fun valueOf(name: String): Tree = when (name) {
        "Tree_B_C_F_G" -> Tree.B.C.F.G
        "Tree_B_C_F_H" -> Tree.B.C.F.H
        "Tree_B_C_F_I" -> Tree.B.C.F.I
        "Tree_B_C_D" -> Tree.B.C.D
        "Tree_B_C_E" -> Tree.B.C.E
        "Tree_B_C_J" -> Tree.B.C.J
        "Tree_L_M_N" -> Tree.L.M.N
        "Tree_L_M_O" -> Tree.L.M.O
        "Tree_L_P_Q" -> Tree.L.P.Q
        "Tree_L_P_R" -> Tree.L.P.R
        "Tree_L_S" -> Tree.L.S
        "Tree_A" -> Tree.A
        "Tree_K" -> Tree.K
        "Tree_T" -> Tree.T
        else -> throw IllegalArgumentException("""No sealed enum constant $name""")
    }

    public override fun sealedObjectToEnum(obj: Tree): TreePostOrderEnum = when (obj) {
        is Tree.B.C.F.G -> TreePostOrderEnum.Tree_B_C_F_G
        is Tree.B.C.F.H -> TreePostOrderEnum.Tree_B_C_F_H
        is Tree.B.C.F.I -> TreePostOrderEnum.Tree_B_C_F_I
        is Tree.B.C.D -> TreePostOrderEnum.Tree_B_C_D
        is Tree.B.C.E -> TreePostOrderEnum.Tree_B_C_E
        is Tree.B.C.J -> TreePostOrderEnum.Tree_B_C_J
        is Tree.L.M.N -> TreePostOrderEnum.Tree_L_M_N
        is Tree.L.M.O -> TreePostOrderEnum.Tree_L_M_O
        is Tree.L.P.Q -> TreePostOrderEnum.Tree_L_P_Q
        is Tree.L.P.R -> TreePostOrderEnum.Tree_L_P_R
        is Tree.L.S -> TreePostOrderEnum.Tree_L_S
        is Tree.A -> TreePostOrderEnum.Tree_A
        is Tree.K -> TreePostOrderEnum.Tree_K
        is Tree.T -> TreePostOrderEnum.Tree_T
    }

    public override fun enumToSealedObject(`enum`: TreePostOrderEnum): Tree = when (enum) {
        TreePostOrderEnum.Tree_B_C_F_G -> Tree.B.C.F.G
        TreePostOrderEnum.Tree_B_C_F_H -> Tree.B.C.F.H
        TreePostOrderEnum.Tree_B_C_F_I -> Tree.B.C.F.I
        TreePostOrderEnum.Tree_B_C_D -> Tree.B.C.D
        TreePostOrderEnum.Tree_B_C_E -> Tree.B.C.E
        TreePostOrderEnum.Tree_B_C_J -> Tree.B.C.J
        TreePostOrderEnum.Tree_L_M_N -> Tree.L.M.N
        TreePostOrderEnum.Tree_L_M_O -> Tree.L.M.O
        TreePostOrderEnum.Tree_L_P_Q -> Tree.L.P.Q
        TreePostOrderEnum.Tree_L_P_R -> Tree.L.P.R
        TreePostOrderEnum.Tree_L_S -> Tree.L.S
        TreePostOrderEnum.Tree_A -> Tree.A
        TreePostOrderEnum.Tree_K -> Tree.K
        TreePostOrderEnum.Tree_T -> Tree.T
    }
}

/**
 * The index of [this] in the values list.
 */
public val Tree.postOrderOrdinal: Int
    get() = TreePostOrderSealedEnum.ordinalOf(this)

/**
 * The name of [this] for use with valueOf.
 */
public val Tree.postOrderName: String
    get() = TreePostOrderSealedEnum.nameOf(this)

/**
 * A list of all [Tree] objects.
 */
public val Tree.Companion.postOrderValues: List<Tree>
    get() = TreePostOrderSealedEnum.values

/**
 * Returns an implementation of [SealedEnum] for the sealed class [Tree]
 */
public val Tree.Companion.postOrderSealedEnum: TreePostOrderSealedEnum
    get() = TreePostOrderSealedEnum

/**
 * Returns the [Tree] object for the given [name].
 *
 * If the given name doesn't correspond to any [Tree], an [IllegalArgumentException] will be thrown.
 */
public fun Tree.Companion.postOrderValueOf(name: String): Tree =
        TreePostOrderSealedEnum.valueOf(name)

/**
 * An isomorphic enum for the sealed class [Tree]
 */
public enum class TreeInOrderEnum() {
    Tree_A,
    Tree_B_C_D,
    Tree_B_C_E,
    Tree_B_C_F_G,
    Tree_B_C_F_H,
    Tree_B_C_F_I,
    Tree_B_C_J,
    Tree_K,
    Tree_L_M_N,
    Tree_L_M_O,
    Tree_L_P_Q,
    Tree_L_P_R,
    Tree_L_S,
    Tree_T,
}

/**
 * The isomorphic [TreeInOrderEnum] for [this].
 */
public val Tree.inOrderEnum: TreeInOrderEnum
    get() = TreeInOrderSealedEnum.sealedObjectToEnum(this)

/**
 * The isomorphic [Tree] for [this].
 */
public val TreeInOrderEnum.sealedObject: Tree
    get() = TreeInOrderSealedEnum.enumToSealedObject(this)

/**
 * An implementation of [SealedEnum] for the sealed class [Tree]
 */
public object TreeInOrderSealedEnum : SealedEnum<Tree>,
        SealedEnumWithEnumProvider<Tree, TreeInOrderEnum>,
        EnumForSealedEnumProvider<Tree, TreeInOrderEnum> {
    public override val values: List<Tree> by lazy(mode = LazyThreadSafetyMode.PUBLICATION) {
        listOf(
            Tree.A,
            Tree.B.C.D,
            Tree.B.C.E,
            Tree.B.C.F.G,
            Tree.B.C.F.H,
            Tree.B.C.F.I,
            Tree.B.C.J,
            Tree.K,
            Tree.L.M.N,
            Tree.L.M.O,
            Tree.L.P.Q,
            Tree.L.P.R,
            Tree.L.S,
            Tree.T
        )
    }


    public override val enumClass: KClass<TreeInOrderEnum>
        get() = TreeInOrderEnum::class

    public override fun ordinalOf(obj: Tree): Int = when (obj) {
        is Tree.A -> 0
        is Tree.B.C.D -> 1
        is Tree.B.C.E -> 2
        is Tree.B.C.F.G -> 3
        is Tree.B.C.F.H -> 4
        is Tree.B.C.F.I -> 5
        is Tree.B.C.J -> 6
        is Tree.K -> 7
        is Tree.L.M.N -> 8
        is Tree.L.M.O -> 9
        is Tree.L.P.Q -> 10
        is Tree.L.P.R -> 11
        is Tree.L.S -> 12
        is Tree.T -> 13
    }

    public override fun nameOf(obj: Tree): String = when (obj) {
        is Tree.A -> "Tree_A"
        is Tree.B.C.D -> "Tree_B_C_D"
        is Tree.B.C.E -> "Tree_B_C_E"
        is Tree.B.C.F.G -> "Tree_B_C_F_G"
        is Tree.B.C.F.H -> "Tree_B_C_F_H"
        is Tree.B.C.F.I -> "Tree_B_C_F_I"
        is Tree.B.C.J -> "Tree_B_C_J"
        is Tree.K -> "Tree_K"
        is Tree.L.M.N -> "Tree_L_M_N"
        is Tree.L.M.O -> "Tree_L_M_O"
        is Tree.L.P.Q -> "Tree_L_P_Q"
        is Tree.L.P.R -> "Tree_L_P_R"
        is Tree.L.S -> "Tree_L_S"
        is Tree.T -> "Tree_T"
    }

    public override fun valueOf(name: String): Tree = when (name) {
        "Tree_A" -> Tree.A
        "Tree_B_C_D" -> Tree.B.C.D
        "Tree_B_C_E" -> Tree.B.C.E
        "Tree_B_C_F_G" -> Tree.B.C.F.G
        "Tree_B_C_F_H" -> Tree.B.C.F.H
        "Tree_B_C_F_I" -> Tree.B.C.F.I
        "Tree_B_C_J" -> Tree.B.C.J
        "Tree_K" -> Tree.K
        "Tree_L_M_N" -> Tree.L.M.N
        "Tree_L_M_O" -> Tree.L.M.O
        "Tree_L_P_Q" -> Tree.L.P.Q
        "Tree_L_P_R" -> Tree.L.P.R
        "Tree_L_S" -> Tree.L.S
        "Tree_T" -> Tree.T
        else -> throw IllegalArgumentException("""No sealed enum constant $name""")
    }

    public override fun sealedObjectToEnum(obj: Tree): TreeInOrderEnum = when (obj) {
        is Tree.A -> TreeInOrderEnum.Tree_A
        is Tree.B.C.D -> TreeInOrderEnum.Tree_B_C_D
        is Tree.B.C.E -> TreeInOrderEnum.Tree_B_C_E
        is Tree.B.C.F.G -> TreeInOrderEnum.Tree_B_C_F_G
        is Tree.B.C.F.H -> TreeInOrderEnum.Tree_B_C_F_H
        is Tree.B.C.F.I -> TreeInOrderEnum.Tree_B_C_F_I
        is Tree.B.C.J -> TreeInOrderEnum.Tree_B_C_J
        is Tree.K -> TreeInOrderEnum.Tree_K
        is Tree.L.M.N -> TreeInOrderEnum.Tree_L_M_N
        is Tree.L.M.O -> TreeInOrderEnum.Tree_L_M_O
        is Tree.L.P.Q -> TreeInOrderEnum.Tree_L_P_Q
        is Tree.L.P.R -> TreeInOrderEnum.Tree_L_P_R
        is Tree.L.S -> TreeInOrderEnum.Tree_L_S
        is Tree.T -> TreeInOrderEnum.Tree_T
    }

    public override fun enumToSealedObject(`enum`: TreeInOrderEnum): Tree = when (enum) {
        TreeInOrderEnum.Tree_A -> Tree.A
        TreeInOrderEnum.Tree_B_C_D -> Tree.B.C.D
        TreeInOrderEnum.Tree_B_C_E -> Tree.B.C.E
        TreeInOrderEnum.Tree_B_C_F_G -> Tree.B.C.F.G
        TreeInOrderEnum.Tree_B_C_F_H -> Tree.B.C.F.H
        TreeInOrderEnum.Tree_B_C_F_I -> Tree.B.C.F.I
        TreeInOrderEnum.Tree_B_C_J -> Tree.B.C.J
        TreeInOrderEnum.Tree_K -> Tree.K
        TreeInOrderEnum.Tree_L_M_N -> Tree.L.M.N
        TreeInOrderEnum.Tree_L_M_O -> Tree.L.M.O
        TreeInOrderEnum.Tree_L_P_Q -> Tree.L.P.Q
        TreeInOrderEnum.Tree_L_P_R -> Tree.L.P.R
        TreeInOrderEnum.Tree_L_S -> Tree.L.S
        TreeInOrderEnum.Tree_T -> Tree.T
    }
}

/**
 * The index of [this] in the values list.
 */
public val Tree.inOrderOrdinal: Int
    get() = TreeInOrderSealedEnum.ordinalOf(this)

/**
 * The name of [this] for use with valueOf.
 */
public val Tree.inOrderName: String
    get() = TreeInOrderSealedEnum.nameOf(this)

/**
 * A list of all [Tree] objects.
 */
public val Tree.Companion.inOrderValues: List<Tree>
    get() = TreeInOrderSealedEnum.values

/**
 * Returns an implementation of [SealedEnum] for the sealed class [Tree]
 */
public val Tree.Companion.inOrderSealedEnum: TreeInOrderSealedEnum
    get() = TreeInOrderSealedEnum

/**
 * Returns the [Tree] object for the given [name].
 *
 * If the given name doesn't correspond to any [Tree], an [IllegalArgumentException] will be thrown.
 */
public fun Tree.Companion.inOrderValueOf(name: String): Tree = TreeInOrderSealedEnum.valueOf(name)

/**
 * An isomorphic enum for the sealed class [Tree]
 */
public enum class TreePreOrderEnum() {
    Tree_A,
    Tree_K,
    Tree_T,
    Tree_B_C_D,
    Tree_B_C_E,
    Tree_B_C_J,
    Tree_B_C_F_G,
    Tree_B_C_F_H,
    Tree_B_C_F_I,
    Tree_L_S,
    Tree_L_M_N,
    Tree_L_M_O,
    Tree_L_P_Q,
    Tree_L_P_R,
}

/**
 * The isomorphic [TreePreOrderEnum] for [this].
 */
public val Tree.preOrderEnum: TreePreOrderEnum
    get() = TreePreOrderSealedEnum.sealedObjectToEnum(this)

/**
 * The isomorphic [Tree] for [this].
 */
public val TreePreOrderEnum.sealedObject: Tree
    get() = TreePreOrderSealedEnum.enumToSealedObject(this)

/**
 * An implementation of [SealedEnum] for the sealed class [Tree]
 */
public object TreePreOrderSealedEnum : SealedEnum<Tree>,
        SealedEnumWithEnumProvider<Tree, TreePreOrderEnum>,
        EnumForSealedEnumProvider<Tree, TreePreOrderEnum> {
    public override val values: List<Tree> by lazy(mode = LazyThreadSafetyMode.PUBLICATION) {
        listOf(
            Tree.A,
            Tree.K,
            Tree.T,
            Tree.B.C.D,
            Tree.B.C.E,
            Tree.B.C.J,
            Tree.B.C.F.G,
            Tree.B.C.F.H,
            Tree.B.C.F.I,
            Tree.L.S,
            Tree.L.M.N,
            Tree.L.M.O,
            Tree.L.P.Q,
            Tree.L.P.R
        )
    }


    public override val enumClass: KClass<TreePreOrderEnum>
        get() = TreePreOrderEnum::class

    public override fun ordinalOf(obj: Tree): Int = when (obj) {
        is Tree.A -> 0
        is Tree.K -> 1
        is Tree.T -> 2
        is Tree.B.C.D -> 3
        is Tree.B.C.E -> 4
        is Tree.B.C.J -> 5
        is Tree.B.C.F.G -> 6
        is Tree.B.C.F.H -> 7
        is Tree.B.C.F.I -> 8
        is Tree.L.S -> 9
        is Tree.L.M.N -> 10
        is Tree.L.M.O -> 11
        is Tree.L.P.Q -> 12
        is Tree.L.P.R -> 13
    }

    public override fun nameOf(obj: Tree): String = when (obj) {
        is Tree.A -> "Tree_A"
        is Tree.K -> "Tree_K"
        is Tree.T -> "Tree_T"
        is Tree.B.C.D -> "Tree_B_C_D"
        is Tree.B.C.E -> "Tree_B_C_E"
        is Tree.B.C.J -> "Tree_B_C_J"
        is Tree.B.C.F.G -> "Tree_B_C_F_G"
        is Tree.B.C.F.H -> "Tree_B_C_F_H"
        is Tree.B.C.F.I -> "Tree_B_C_F_I"
        is Tree.L.S -> "Tree_L_S"
        is Tree.L.M.N -> "Tree_L_M_N"
        is Tree.L.M.O -> "Tree_L_M_O"
        is Tree.L.P.Q -> "Tree_L_P_Q"
        is Tree.L.P.R -> "Tree_L_P_R"
    }

    public override fun valueOf(name: String): Tree = when (name) {
        "Tree_A" -> Tree.A
        "Tree_K" -> Tree.K
        "Tree_T" -> Tree.T
        "Tree_B_C_D" -> Tree.B.C.D
        "Tree_B_C_E" -> Tree.B.C.E
        "Tree_B_C_J" -> Tree.B.C.J
        "Tree_B_C_F_G" -> Tree.B.C.F.G
        "Tree_B_C_F_H" -> Tree.B.C.F.H
        "Tree_B_C_F_I" -> Tree.B.C.F.I
        "Tree_L_S" -> Tree.L.S
        "Tree_L_M_N" -> Tree.L.M.N
        "Tree_L_M_O" -> Tree.L.M.O
        "Tree_L_P_Q" -> Tree.L.P.Q
        "Tree_L_P_R" -> Tree.L.P.R
        else -> throw IllegalArgumentException("""No sealed enum constant $name""")
    }

    public override fun sealedObjectToEnum(obj: Tree): TreePreOrderEnum = when (obj) {
        is Tree.A -> TreePreOrderEnum.Tree_A
        is Tree.K -> TreePreOrderEnum.Tree_K
        is Tree.T -> TreePreOrderEnum.Tree_T
        is Tree.B.C.D -> TreePreOrderEnum.Tree_B_C_D
        is Tree.B.C.E -> TreePreOrderEnum.Tree_B_C_E
        is Tree.B.C.J -> TreePreOrderEnum.Tree_B_C_J
        is Tree.B.C.F.G -> TreePreOrderEnum.Tree_B_C_F_G
        is Tree.B.C.F.H -> TreePreOrderEnum.Tree_B_C_F_H
        is Tree.B.C.F.I -> TreePreOrderEnum.Tree_B_C_F_I
        is Tree.L.S -> TreePreOrderEnum.Tree_L_S
        is Tree.L.M.N -> TreePreOrderEnum.Tree_L_M_N
        is Tree.L.M.O -> TreePreOrderEnum.Tree_L_M_O
        is Tree.L.P.Q -> TreePreOrderEnum.Tree_L_P_Q
        is Tree.L.P.R -> TreePreOrderEnum.Tree_L_P_R
    }

    public override fun enumToSealedObject(`enum`: TreePreOrderEnum): Tree = when (enum) {
        TreePreOrderEnum.Tree_A -> Tree.A
        TreePreOrderEnum.Tree_K -> Tree.K
        TreePreOrderEnum.Tree_T -> Tree.T
        TreePreOrderEnum.Tree_B_C_D -> Tree.B.C.D
        TreePreOrderEnum.Tree_B_C_E -> Tree.B.C.E
        TreePreOrderEnum.Tree_B_C_J -> Tree.B.C.J
        TreePreOrderEnum.Tree_B_C_F_G -> Tree.B.C.F.G
        TreePreOrderEnum.Tree_B_C_F_H -> Tree.B.C.F.H
        TreePreOrderEnum.Tree_B_C_F_I -> Tree.B.C.F.I
        TreePreOrderEnum.Tree_L_S -> Tree.L.S
        TreePreOrderEnum.Tree_L_M_N -> Tree.L.M.N
        TreePreOrderEnum.Tree_L_M_O -> Tree.L.M.O
        TreePreOrderEnum.Tree_L_P_Q -> Tree.L.P.Q
        TreePreOrderEnum.Tree_L_P_R -> Tree.L.P.R
    }
}

/**
 * The index of [this] in the values list.
 */
public val Tree.preOrderOrdinal: Int
    get() = TreePreOrderSealedEnum.ordinalOf(this)

/**
 * The name of [this] for use with valueOf.
 */
public val Tree.preOrderName: String
    get() = TreePreOrderSealedEnum.nameOf(this)

/**
 * A list of all [Tree] objects.
 */
public val Tree.Companion.preOrderValues: List<Tree>
    get() = TreePreOrderSealedEnum.values

/**
 * Returns an implementation of [SealedEnum] for the sealed class [Tree]
 */
public val Tree.Companion.preOrderSealedEnum: TreePreOrderSealedEnum
    get() = TreePreOrderSealedEnum

/**
 * Returns the [Tree] object for the given [name].
 *
 * If the given name doesn't correspond to any [Tree], an [IllegalArgumentException] will be thrown.
 */
public fun Tree.Companion.preOrderValueOf(name: String): Tree = TreePreOrderSealedEnum.valueOf(name)
